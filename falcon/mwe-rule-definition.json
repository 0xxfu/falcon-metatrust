{
  "array-in-abiencode": {
    "code": "array-in-abiencode",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-001: Using Potentially Buggy ABIEncoderV2",
    "wiki_description": "0.5.9 contain a compiler bug leading to incorrect ABI encoder usage. During the encoding process, the ABI encoder does not properly advance the next element in an array when the elements occupy more than a single slot in storage. It may lead to malfunction or exploitability. Until solidity 0.6.0, the ABIEncoderV2 feature is still technically in an experimental state. Although there are no known security risks associated, these features should be used judiciously.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Upgrade the contracts to a more recent solidity version. All contracts that depend upon ABIEncoderV2 functionality should be tested thoroughly.",
    "id": "MWE-001"
  },
  "arbitrary-transferfrom": {
    "code": "arbitrary-transferfrom",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-002: Missing `msg.sender` Check for transferFrom()",
    "wiki_description": "When we use the `ERC20` method `transferFrom`, the parameter from should be carefully checked. It shouldn't be an arbitrary address that may lead to someone `transfer` anyone's token to himself.  So we, for instance, should detect whether `msg.sender` was used as `from` in transferFrom.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use `msg.sender` to check the parameter `from` in transferFrom.",
    "id": "MWE-002"
  },
  "arbitrary-permit": {
    "code": "arbitrary-permit",
    "impact": "HIGH",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-003: Method permit() Used for Arbitrary `from` in transferFrom()",
    "wiki_description": "Method `permit` is used in ERC20 token, which is used to change an account's ERC20 allowance by presenting a message signed by the account. By not relying on `approve` method, the token holder account doesn't need to send a transaction. When we use this method in `transferFrom` and `msg.sender` is not used as from in transferFrom. If an ERC20 token does not implement `permit` and has a fallback function, `transferFrom` allows an attacker to transfer all tokens approved for this contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Ensure that the underlying ERC20 token correctly implements a permit function.",
    "id": "MWE-003"
  },
  "arbitrary-transfer": {
    "code": "arbitrary-transfer",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-004: Sending Ether to Arbitrary Destinations",
    "wiki_description": "When we use function `call` to send ether, the target address should be carefully checked, and an arbitrary address may lead to exploitability.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Ensure that an arbitrary user cannot withdraw unauthorized funds.",
    "id": "MWE-004"
  },
  "reference-pass": {
    "code": "reference-pass",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-005: Modifying storage array by value",
    "wiki_description": "When arrays are passed to a function that expects a reference to a storage array, they should be tested to make sure the expected result. Usually, memory is used in function parameters, and assignment to storage variables should be made in a function body.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit.",
    "id": "MWE-005"
  },
  "array-length-assignment": {
    "code": "array-length-assignment",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-006: Unsafe Array Length Assignment ",
    "wiki_description": "User-controlled variables cannot reach an array length assignment.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "User-controlled variables cannot reach an array length assignment.",
    "id": "MWE-006"
  },
  "misuse-assert": {
    "code": "misuse-assert",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-007: Missing Assert Statements",
    "wiki_description": "As an error handling function, assert creates an error of type Panic(uint256) . It should only be used to test for internal errors, and to check invariant.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use `require` for invariants modifying the state.",
    "id": "MWE-007"
  },
  "prng": {
    "code": "prng",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-008: Weak PRNG (Pseudorandom Number Generator)",
    "wiki_description": "`block.timestamp`, `now`, `block.difficulty`, and `blockhash` miners can influence these values, so they should not be used to generate random numbers.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Instead of using `block.timestamp`, `block.difficulty`, `msg.sender`, `block.coinbase`, `block.number`, `gasLeft` or `blockhash` as a source of randomness, we recommend using a verifiable source of randomness, such as Chainlink VRF, for random number generation.",
    "id": "MWE-008"
  },
  "unnecessary-boolean-compare": {
    "code": "unnecessary-boolean-compare",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-009: Unnecessary Boolean Comparison",
    "wiki_description": "Boolean constants can be used directly and do not need to compare to true or false.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Just use boolean constants directly.",
    "id": "MWE-009"
  },
  "builtin-symbol": {
    "code": "builtin-symbol",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-010: Usage of Builtin Symbols ",
    "wiki_description": "Builtin symbols may lead to unexpected results.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Rename the local variables, state variables, functions, modifiers, and events that shadow a builtin symbol.",
    "id": "MWE-010"
  },
  "state-should-be-constant": {
    "code": "state-should-be-constant",
    "impact": "OPTIMIZATION",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-011: Potential Constant State Variables",
    "wiki_description": "Constant state variables should be declared constant to save gas.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add the `constant` attributes to state variables that never change.",
    "id": "MWE-011"
  },
  "different-pragma": {
    "code": "different-pragma",
    "impact": "OPTIMIZATION",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-012: Conflict of Different Solidity Versions",
    "wiki_description": "Different Solidity versions are used between contracts or imported libraries, which may lead to unexpected compile errors.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use the same Solidity version to avoid unexpected compile errors.",
    "id": "MWE-012"
  },
  "arbitrary-delegatecall": {
    "code": "arbitrary-delegatecall",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-013: Unsafe Delegatecall ",
    "wiki_description": "`delegatecall` is different from `call`. When using `delegatecall`, the code at the target address is executed in the current contract context, which means it will change the current contract's storage, which may lead to an unexpected result. So the target address should be carefully checked before using it.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use `delegatecall` with caution, and use only trusted destinations. In addition, the storage data structure should be checked between the proxy and target contract.",
    "id": "MWE-013"
  },
  "delegatecall-in-payable-func": {
    "code": "delegatecall-in-payable-func",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-014: Payable Functions using `delegatecall` inside a Loop ",
    "wiki_description": "Detect the use of delegatecall inside a loop in a payable function. When delegatecall is used in a payable function, msg.value is passed to the target contract. Potential security issues arise when the target function of the delegatecall uses msg.value for data storage, especially when delegatecall is used inside a loop. In this context, the amount or balance will be credited multiple times, potentially leading to unforeseen consequences.\n\nFor example:\n\n```solidity\ncontract DelegatecallInLoop{\n\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i = 0; i < receivers.length; i++) {\n            address(this).delegatecall(abi.encodeWithSignature(\"addBalance(address)\", receivers[i]));\n        }\n    }\n\n    function addBalance(address a) public payable {\n        balances[a] += msg.value;\n    } \n\n}\n```\nWhen calling bad the same `msg.value` amount will be accredited multiple times.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Carefully check that the function called by `delegatecall` is not payable/doesn't use `msg.value`",
    "id": "MWE-014"
  },
  "deprecated-usage": {
    "code": "deprecated-usage",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-015: Usage of Deprecated Standards",
    "wiki_description": "Detect the usage of deprecated standards.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Replace all uses of deprecated symbols.",
    "id": "MWE-015"
  },
  "arithmetic-order": {
    "code": "arithmetic-order",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-016: Inappropriate Integer Division before Multiplication",
    "wiki_description": "Performing integer division before multiplication truncates the low bits, losing the precision of the calculation.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Consider ordering multiplication before division.",
    "id": "MWE-016"
  },
  "enum-range": {
    "code": "enum-range",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-017: Out-of-range Enum Conversion ",
    "wiki_description": "Detect out-of-range `enum` conversion (`solc` < `0.4.5`).",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use a recent compiler version. If `solc` <`0.4.5` is required, check the `enum` conversion range.",
    "id": "MWE-017"
  },
  "incorrect-erc20-interface": {
    "code": "incorrect-erc20-interface",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-018: Incorrect ERC20 Interface ",
    "wiki_description": "A nonstandard ERC20 interface may halt interaction with a contract compiled with Solidity > 0.4.22 as the return value is missing.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Set the appropriate return values and types for the defined `ERC20` functions.",
    "id": "MWE-018"
  },
  "erc721-interface": {
    "code": "erc721-interface",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-019: Incorrect ERC721 Interface ",
    "wiki_description": "A nonstandard ERC721 interface may halt interaction with a contract compiled with Solidity > 0.4.22 as the return value is missing.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Set the appropriate return values and types for the defined `ERC721` functions.",
    "id": "MWE-019"
  },
  "dangerous-unary": {
    "code": "dangerous-unary",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-020: Dangerous Unary Expressions ",
    "wiki_description": "Unary expressions such as `x=+1` probably typos.\n\nFor example:\n```solidity\ncontract Bug{\n    uint public counter;\n\n    function increase() public returns(uint){\n        counter=+1;\n        return counter;\n    }\n}\n```\n`increase()` uses `=+` instead of `+=`, so counter will never exceed 1.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove the unary expression.",
    "id": "MWE-020"
  },
  "local-variable-shadowing": {
    "code": "local-variable-shadowing",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-021: Shadowing using Local Variables",
    "wiki_description": "Detection of shadowing using local variables.\n\nFor example:\n```solidity\npragma solidity ^0.4.24;\n\ncontract Bug {\n    uint owner;\n\n    function sensitive_function(address owner) public {\n        // ...require(owner == msg.sender);\n    }\n\n    function alternate_sensitive_function() public {\n        address owner = msg.sender;\n        // ...require(owner == msg.sender);\n    }\n}\n```\n`sensitive_function.owner` shadows `Bug.owner`. As a result, the use of owner in `sensitive_function` might be incorrect.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Rename the local variables that shadow another component.",
    "id": "MWE-021"
  },
  "ether-locked": {
    "code": "ether-locked",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-022: Contract Could Lock Ether ",
    "wiki_description": "Contract with a `payable` function but without a withdrawal capacity.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove the payable attribute or add a withdraw function.",
    "id": "MWE-022"
  },
  "invalid-array-deletion": {
    "code": "invalid-array-deletion",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-023: Invalid Array Deletion",
    "wiki_description": "A deletion in a structure containing a mapping will not delete the mapping (see the [Solidity documentation](https://solidity.readthedocs.io/en/latest/types.html##delete)). The remaining data may be used to compromise the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use a lock mechanism instead of deletion to disable a structure containing a mapping.",
    "id": "MWE-023"
  },
  "missing-events": {
    "code": "missing-events",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-024: Missing Events for Critical Arithmetic ",
    "wiki_description": "Detect missing events for critical arithmetic parameters.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Emit an event for critical parameter changes.",
    "id": "MWE-024"
  },
  "modifier-without-underscore": {
    "code": "modifier-without-underscore",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-025: Incorrect modifier ",
    "wiki_description": "If a modifier does not execute `_` or revert, the execution of the function will return the default value, which can be misleading for the caller.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "All the paths in a modifier must execute `_` or revert.",
    "id": "MWE-025"
  },
  "dangerous-msg-value-usage": {
    "code": "dangerous-msg-value-usage",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-026: Dangerous Usage of `msg.value` inside a Loop ",
    "wiki_description": "Detect the use of `msg.value` inside a loop.\n\nFor example:\n```solidity\ncontract MsgValueInLoop{\n    mapping (address => uint256) balances;\n\n    function bad(address[] memory receivers) public payable {\n        for (uint256 i=0; i < receivers.length; i++) {\n            balances[receivers[i]] += msg.value;\n        }\n    }\n}\n```",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Track `msg.value` through a local variable and decrease its amount on every iteration/usage.",
    "id": "MWE-026"
  },
  "misuse-constructors": {
    "code": "misuse-constructors",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-027: Multiple Constructor Definitions in the Same Contract ",
    "wiki_description": "In Solidity `0.4.22`, a contract can have two constructors, `constructor(...)` and function `<contractName>(...)`. The first constructor will precede the second, which may lead to unexpected results.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Only declare one constructor, preferably using the new scheme `constructor(...)` instead of `function <contractName>(...)`.",
    "id": "MWE-027"
  },
  "same-name": {
    "code": "same-name",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-028: Reused Contract Name",
    "wiki_description": "When we use compilation artifacts to organize our codebase, such as truffle\u3001hardhat, only one of the two contracts will generate artifacts if two contracts have the same name in the codebase. As a result, the second contract cannot be analyzed.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use different contract name in the same codebase.",
    "id": "MWE-028"
  },
  "structure-in-mappings": {
    "code": "structure-in-mappings",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-029: Public Mappings with Nested Variables ",
    "wiki_description": "Prior to Solidity 0.5, a public mapping with nested structures returned [incorrect values](https://github.com/ethereum/solidity/issues/5520).",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Do not use public mapping with nested structures.",
    "id": "MWE-029"
  },
  "redundant-code": {
    "code": "redundant-code",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-030: Redundant Code Statements ",
    "wiki_description": "Redundant statements like types or identifiers that have no action performed on them do not affect the functionality of the codebase. However, as a result, they congest code and reduce code readability. Moreover, they may lead to unnecessary gas costs.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove redundant statements to improve code readability, prepare a better production environment, and optimize gas.",
    "id": "MWE-030"
  },
  "reentrancy-same-effect": {
    "code": "reentrancy-same-effect",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-031: Reentrancy Vulnerability",
    "wiki_description": "A state variable is changed after a contract calls another contract function. The target contract can callback and reenter before the state variable is updated. This may lead to an unexpected result.\n\nFor example:\n```solidity\nfunction withdrawBalance(){\n  // send userBalance[msg.sender] Ether to msg.sender\n  // if mgs.sender is a contract, it will call its fallback function\n  if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n      throw;\n  }\n  userBalance[msg.sender] = 0;\n}\n```\n`msg.sender` can reenter the withdrawBalance function and withdraw all ether in the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "id": "MWE-031"
  },
  "reentrancy-with-eth-transfer": {
    "code": "reentrancy-with-eth-transfer",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-032: Reentrancy Vulnerability with ETH Transfer ",
    "wiki_description": "A state variable is changed after a contract calls another contract function. The target contract can callback and reenter before the state variable is updated. This may lead to an unexpected result.\n\nFor example:\n```solidity\nfunction withdrawBalance(){\n  // send userBalance[msg.sender] Ether to msg.sender\n  // if mgs.sender is a contract, it will call its fallback function\n  if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n      throw;\n  }\n  userBalance[msg.sender] = 0;\n}\n```\n`msg.sender` can reenter the withdrawBalance function and withdraw all ether in the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "id": "MWE-032"
  },
  "reentrancy-with-negative-events": {
    "code": "reentrancy-with-negative-events",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-033: Reentrancy Vulnerability ",
    "wiki_description": "A state variable is changed after a contract calls another contract function. The target contract can callback and reenter before the state variable is updated. This may lead to an unexpected result.\n\nFor example:\n```solidity\nfunction withdrawBalance(){\n  // send userBalance[msg.sender] Ether to msg.sender\n  // if mgs.sender is a contract, it will call its fallback function\n  if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n      throw;\n  }\n  userBalance[msg.sender] = 0;\n}\n```\n`msg.sender` can reenter the withdrawBalance function and withdraw all ether in the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "id": "MWE-033"
  },
  "transfer-reentrancy": {
    "code": "transfer-reentrancy",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-034: Reentrancy Vulnerability ",
    "wiki_description": "A state variable is changed after a contract calls another contract function. The target contract can callback and reenter before the state variable is updated. This may lead to an unexpected result.\n\nFor example:\n```solidity\nfunction withdrawBalance(){\n  // send userBalance[msg.sender] Ether to msg.sender\n  // if mgs.sender is a contract, it will call its fallback function\n  if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n      throw;\n  }\n  userBalance[msg.sender] = 0;\n}\n```\n`msg.sender` can reenter the withdrawBalance function and withdraw all ether in the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "id": "MWE-034"
  },
  "reentrancy-without-eth-transfer": {
    "code": "reentrancy-without-eth-transfer",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-035: Reentrancy Vulnerability without ETH Transfer ",
    "wiki_description": "A state variable is changed after a contract calls another contract function. The target contract can callback and reenter before the state variable is updated. This may lead to an unexpected result.\n\nFor example:\n```solidity\nfunction withdrawBalance(){\n  // send userBalance[msg.sender] Ether to msg.sender\n  // if mgs.sender is a contract, it will call its fallback function\n  if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n      throw;\n  }\n  userBalance[msg.sender] = 0;\n}\n```\n`msg.sender` can reenter the withdrawBalance function and withdraw all ether in the contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Apply the [`check-effects-interactions pattern`](http://solidity.readthedocs.io/en/v0.4.21/security-considerations.html#re-entrancy).",
    "id": "MWE-035"
  },
  "construct-multi-times": {
    "code": "construct-multi-times",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-036: Reused Constructor Arguments",
    "wiki_description": "Constructor arguments of the base contract are given multiple times. The constructor of derived contracts initializes the base contract many times in multiple and multilevel inheritances.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove the duplicate constructor call.",
    "id": "MWE-036"
  },
  "rtlo": {
    "code": "rtlo",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-037: Right-to-Left-Override Unicode Character",
    "wiki_description": "Right-To-Left-Override Unicode character will force RTL text rendering and confuse users with the real intent of a contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "There are very few legitimate uses of the U+202E character. It should not appear in the source code of a smart contract.",
    "id": "MWE-037"
  },
  "similar-names": {
    "code": "similar-names",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-038: Variables with Similar Names",
    "wiki_description": "Detect variables with names that are too similar.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Prevent variables from having similar names.",
    "id": "MWE-038"
  },
  "state-variable-shadowing": {
    "code": "state-variable-shadowing",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-039: Potential Overridden State Variables",
    "wiki_description": "Before Solidity 0.6, state variables can be overridden by re-declaring it in the child contract. If we assign variable in child contract, the shadowed variable in parent contract still be zero value. This will be out of our expectations and vulnerabilities comes. For example, the following method withdraw will never succeed.\n```solidity\ncontract BaseContract{\n  address owner;\n\n  modifier isOwner(){\n      require(owner == msg.sender);\n      _;\n  }\n}\ncontract DerivedContract is BaseContract{\n  address owner;\n\n  constructor(){\n      owner = msg.sender;\n  }\n\n  function withdraw() isOwner() external{\n      msg.sender.transfer(this.balance);\n  }\n}\n```",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "After Solidity 0.6, state variable shadowing is disallowed. If we have to use solidity with version before 0.6,make sure do not use state variable shadowing.",
    "id": "MWE-039"
  },
  "signed-integer-array": {
    "code": "signed-integer-array",
    "impact": "HIGH",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-040: Solidity Storage Array Bugs",
    "wiki_description": "`solc` versions `0.4.7`-`0.5.10` contain [a compiler bug](https://blog.ethereum.org/2019/06/25/solidity-storage-array-bugs)\nleading to incorrect values in signed integer arrays.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use a compiler version >= `0.5.10`.",
    "id": "MWE-040"
  },
  "unprotected-destruct": {
    "code": "unprotected-destruct",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-041: Unprotected Contract Destruction",
    "wiki_description": "`selfdestruct`/`suicide` are keywords used to terminate a contract, remove the bytecode from the Ethereum blockchain, and send any contract funds to a specified address. We primarily use the `selfdestruct` function to improve smart contract code security, clean up unused contracts and transfer Ethereum assets quickly. However, `selfdestruct` is a double-edged sword, this function gives an easier avenue for a project\u2019s core team to rug their users or community, and assets like `ERC20/ERC721` will never be recovered once `selfdestruct` is called.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "We should use `selfdestruct` carefully and add protections to this kind of function call.",
    "id": "MWE-041"
  },
  "timestamp": {
    "code": "timestamp",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-042: Dangerous Usage of `block.timestamp` ",
    "wiki_description": "Dangerous usage of `block.timestamp`. `block.timestamp` can be manipulated by miners.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid relying on `block.timestamp`.",
    "id": "MWE-042"
  },
  "tx-origin-usage": {
    "code": "tx-origin-usage",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-043: Dangerous Usage of `tx.origin` ",
    "wiki_description": "It is not recommended to use `tx.origin` for authorization. `tx.origin` based protection can be abused by a malicious contract if a legitimate user interacts with the malicious contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Do not use `tx.origin` for authorization.",
    "id": "MWE-043"
  },
  "tautology-or-contradiction": {
    "code": "tautology-or-contradiction",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-044: Condition Expressions with Tautology or Contradiction",
    "wiki_description": "Conditional expression infers trivial(constant) boolean value, for instance, due to the range of the type( uint8 a <256 forever is true).",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Fix the incorrect comparison by changing the value type or the comparison.",
    "id": "MWE-044"
  },
  "no-derived-function": {
    "code": "no-derived-function",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-045: Unimplemented Functions ",
    "wiki_description": "Detect functions that are not implemented on derived-most contracts.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Implement all unimplemented functions in any contract you intend to use directly (not simply inherit from).",
    "id": "MWE-045"
  },
  "erc20-indexed": {
    "code": "erc20-indexed",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-046: Unindexed ERC20 Event Parameters ",
    "wiki_description": "Detects whether events defined by the `ERC20` specification that should have some parameters as `indexed` are missing the `indexed` keyword.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add the `indexed` keyword to event parameters that should include it, according to the `ERC20` specification.",
    "id": "MWE-046"
  },
  "uninitialized-func-pointer": {
    "code": "uninitialized-func-pointer",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-047: Uninitialized Function Pointers in Constructors ",
    "wiki_description": "solc versions `0.4.5`-`0.4.26` and `0.5.0`-`0.5.8` contain a compiler bug leading to unexpected behavior when calling uninitialized function pointers in constructors.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Initialize function pointers before calling. Avoid function pointers if possible.",
    "id": "MWE-047"
  },
  "usage-of-destructed": {
    "code": "usage-of-destructed",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-048: Contract Could be Destructed",
    "wiki_description": "Detects logic contract that can be destructed.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add a constructor to ensure `initialize` cannot be called on the logic contract.",
    "id": "MWE-048"
  },
  "void-constructor": {
    "code": "void-constructor",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-049: Call to Non-implemented Constructor",
    "wiki_description": "Detect the call to a constructor that is not implemented",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove the constructor call.",
    "id": "MWE-049"
  },
  "useless-write": {
    "code": "useless-write",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-050: Useless Write Operations",
    "wiki_description": "Put in variables twice but never read between the assignments. The second assignment operation covers the first assignment that does not work out.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Fix or remove the writes.",
    "id": "MWE-050"
  },
  "input-validation": {
    "code": "input-validation",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-051: Missing Input Validation ",
    "wiki_description": "In solidity, there is no \"null\" equivalent. So we should know every default value for different value types. Meanwhile, we should validate the value passed to state variable. So, for example, when we assign an address type, we should check the value to ensure it's not a zero address.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Validate input value.",
    "id": "MWE-051"
  },
  "error-msg": {
    "code": "error-msg",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-052: Missing Error Message ",
    "wiki_description": "`require` can be used to check for conditions and throw an exception if the condition is not met, in which case the error message provided by the developer will appear. This is why a very descriptive error message is needed.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Adding an error message describing the failed condition.",
    "id": "MWE-052"
  },
  "improper-sig-verify": {
    "code": "improper-sig-verify",
    "impact": "LOW",
    "confidence": "LOW",
    "wiki": "",
    "wiki_title": "MWE-053: Lack of Proper Signature Verification ",
    "wiki_description": "It is a common pattern for smart contract systems to allow users to sign message off-chain instead of directly requesting users to do an on-chain transaction because of the flexibility and increased transferability that this provides. Smart contract systems that process signed messages must implement their own logic to recover the authenticity of the sign messages. Some signature verification implementations attempt to solve this problem by assuming the validity of a signed message based on other methods that do not have this limitation. An example of such a method is to rely on msg.sender and assume that if a signed message originated from the sender address, it has also been created by the sender address. This can lead to vulnerabilities, especially in scenarios where proxies can be used to relay transactions.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "It is not recommended to use alternate verification schemes that do not require proper signature verification through `ecrecover()`.",
    "id": "MWE-053"
  },
  "sig-replay-attacks-protection": {
    "code": "sig-replay-attacks-protection",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-054: Missing Protection against Signature Replay Attacks ",
    "wiki_description": "Sometimes it is necessary to perform signature verification in smart contracts to achieve better usability or to save gas costs. A secure implementation must protect against Signature Replay Attacks by, for example, keeping track of all processed message hashes and only allowing new message hashes. A malicious user could attack a contract without such control and get a message hash sent by another user processed multiple times.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Store every message hash that the smart contract has processed. When new messages are received, check against the already existing ones and only proceed with business logic if it's a new message hash.\\n Include the address of the contract that processes the message. This ensures that the message can only be used in a single contract.\\n- Under no circumstances generate the message hash, including the signature. The `ecrecover` function is susceptible to signature malleability.",
    "id": "MWE-054"
  },
  "signature-malleability": {
    "code": "signature-malleability",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-055: Signature Malleability",
    "wiki_description": "Implementing a cryptographic signature system in Ethereum contracts often assumes that the signature is unique. However, signatures can be altered without possessing the private key and still be valid. The EVM specification defines several so-called `precompiled` contracts, one of which is `ecrecover`, which executes the elliptic curve public key recovery. A malicious user can slightly modify the three values v, r and s to create other valid signatures. A system that performs signature verification on the contract level might be susceptible to attacks if the signature is part of the signed message hash. A malicious user could create valid signatures to replay previously signed messages.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "A signature should never be included in a signed message hash to check if the contract has processed previous messages.",
    "id": "MWE-055"
  },
  "arbitrary-storage-location": {
    "code": "arbitrary-storage-location",
    "impact": "MEDIUM",
    "confidence": "LOW",
    "wiki": "",
    "wiki_title": "MWE-056: Write to Arbitrary Storage Location",
    "wiki_description": "A smart contract's state variables are persistently stored at some storage location named slot on the EVM level. The contract ensures that only legitimate operations can write to sensitive storage locations.\n- However, under the Solidity 0.6 version, this restriction can be circumvented caused by the length of an array is capable of modifying. Primarily the result of the underflow of the length of an array whose type is unit is extremely large. So that arbitrary storage is accessible. Hackers can illegitimately modify state variables by elaborately calculating their location.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "As general advice, given that all data structures share the same storage (address) space, one should make sure that writes to one data structure cannot inadvertently overwrite entries of another data structure.\n- particularly, do not modify the length of an array.",
    "id": "MWE-056"
  },
  "unused-vars": {
    "code": "unused-vars",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-057: Unused Variables",
    "wiki_description": "The presence of state or local variables that are declared but never used in the codebase. They may increase computation costs and lead to unnecessary gas consumption.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove the unused variables to avoid negative effects and improve code readability if there is no plan for further usage.",
    "id": "MWE-057"
  },
  "incorrect-constructor-name": {
    "code": "incorrect-constructor-name",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-058: Incorrect Constructor Name ",
    "wiki_description": "Constructors are special functions that perform privileged and critical actions like setting the owner of the contract. They are called only once during the contract creation. For Solidity version below 0.4.22, the only method to define a constructor is to create a function with the same name as the contract it belongs to. However, the constructor may be wrongly named when the contract code is re-used with a different name while the constructor's name is not changed accordingly. Or typos like different letter cases between contract name and constructor name, which are not obvious. These wrongly matched names can make the constructor a normal and callable function which may lead to security issues.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Solidity version above 0.4.22 introduced a clearer way to define a constructor using a new constructor keyword. Upgrade the contract version to above 0.4.22 and change to the new constructor declaration to avoid this issue.",
    "id": "MWE-058"
  },
  "obsolete-use": {
    "code": "obsolete-use",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-059: Usage of Deprecated Standards",
    "wiki_description": "Detect the usage of deprecated standards.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Replace all uses of deprecated symbols.",
    "id": "MWE-059"
  },
  "unprotected-ether-withdrawal": {
    "code": "unprotected-ether-withdrawal",
    "impact": "CRITICAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-060: Unprotected Ether Withdrawal ",
    "wiki_description": "Because of missing or insufficient access controls, like unintentionally exposing the initialization functions, no subtraction of balance after the refund is called, and wrong comparison operator in withdraw function, some or all Ethers from the contract account can be withdrawn by malicious parties.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Design and implement controls for withdrawals so that only authorized parties can access them.",
    "id": "MWE-060"
  },
  "dos-with-failed-call": {
    "code": "dos-with-failed-call",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-061: DoS With Failed Call ",
    "wiki_description": "External calls can fail accidentally or deliberately, which can cause a DoS condition in the contract. To minimize the damage caused by such failures, it is better to isolate each external call into its transaction that the recipient can initiate. Namely, the state change of the recipient should be initiated by himself. \\nThis is especially relevant for payments, where it is better to let users withdraw funds rather than push funds to them automatically (this also reduces the chance of problems with the gas limit).",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid combining multiple calls in a single transaction, especially when calls are executed as part of a loop. Always assume that external calls can fail. Implement the contract logic to handle failed calls",
    "id": "MWE-061"
  },
  "transaction-order-dependency-high": {
    "code": "transaction-order-dependency-high",
    "impact": "CRITICAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-062: Transaction Order Dependency ",
    "wiki_description": "In the blockchain system, miners look at transactions they have received and select which transactions to include in a block based on who has paid a high enough gas price. Thus, the transactions may not be finalized into the blockchain based on the order of submission. The transaction order dependency occurs when the code depends on the order of the transactions submitted, which may cause unexpected results.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "A possible way to remedy race conditions in submitting information in exchange for a reward is a commit reveal hash scheme. For example, instead of submitting the answer, the party who has the answer submits hash(salt, address, answer) the contract stores this hash and the sender's address. The sender then submits a transaction with the salt and answer to claim the reward. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash. If the hash matches, the contract releases the reward. Another solution is the fix for the ERC20 race condition, where it adds a field to the approved inputs, which is the expected current value.",
    "id": "MWE-062"
  },
  "transaction-order-dependency-medium": {
    "code": "transaction-order-dependency-medium",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-063: Transaction Order Dependency ",
    "wiki_description": "In the blockchain system, miners look at transactions they have received and select which transactions to include in a block based on who has paid a high enough gas price. Thus, the transactions may not be finalized into the blockchain based on the order of submission. The transaction order dependency occurs when the code depends on the order of the transactions submitted, which may cause unexpected results.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "A possible way to remedy race conditions in submitting information in exchange for a reward is a commit reveal hash scheme. For example, instead of submitting the answer, the party who has the answer submits hash(salt, address, answer) the contract stores this hash and the sender's address. The sender then submits a transaction with the salt and answer to claim the reward. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash. If the hash matches, the contract releases the reward. Another solution is the fix for the ERC20 race condition, where it adds a field to the approved inputs, which is the expected current value.",
    "id": "MWE-063"
  },
  "transaction-order-dependency-low": {
    "code": "transaction-order-dependency-low",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-064: Transaction Order Dependency ",
    "wiki_description": "In the blockchain system, miners look at transactions they have received and select which transactions to include in a block based on who has paid a high enough gas price. Thus, the transactions may not be finalized into the blockchain based on the order of submission. The transaction order dependency occurs when the code depends on the order of the transactions submitted, which may cause unexpected results.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "A possible way to remedy race conditions in submitting information in exchange for a reward is a commit reveal hash scheme. For example, instead of submitting the answer, the party who has the answer submits hash(salt, address, answer) the contract stores this hash and the sender's address. The sender then submits a transaction with the salt and answer to claim the reward. The contract hashes (salt, msg.sender, answer) and checks the hash produced against the stored hash. If the hash matches, the contract releases the reward. Another solution is the fix for the ERC20 race condition, where it adds a field to the approved inputs, which is the expected current value.",
    "id": "MWE-064"
  },
  "unindexed-event": {
    "code": "unindexed-event",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-065: Unindexed Event Parameters ",
    "wiki_description": "Events defined by ERC specification should have some parameters as indexed. For example, Transfer and Approval events defined by ERC20 should have the indexed keyword on their first two parameters and Sent event defined by ERC777 should have the indexed keyword on their first three parameters. The parameter data in the transaction/block's bloom filter will be excluded if these keywords are missing. This can lead to neglect in external tooling searching and, therefore, failure to index logs from the token contract.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add the indexed keyword to the declaration of events according to different ERC specifications.",
    "id": "MWE-065"
  },
  "integer-underflow": {
    "code": "integer-underflow",
    "impact": "CRITICAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-066: Integer Underflow",
    "wiki_description": "Overflow is a situation when an unsigned integer reaches its byte size. Then the next element added will return the first variable element. On the contrary, underflow means the preview element will return the last variable element. In Solidity 0.8, the compiler will automatically check for overflow and underflow.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use solc version above 0.8, or use OpenZeppelin\u2019s SafeMath.sol implementation.",
    "id": "MWE-066"
  },
  "caller-check": {
    "code": "caller-check",
    "impact": "CRITICAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-067: Caller Not Checked",
    "wiki_description": "The opcode extcodesize of the caller contract is always zero if the call is from a constructor, though the caller is genuinely a contract account. It results in a false positive when checking whether the caller is a contract account.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Not solely take codesize of account to distinguish a contract account from an external one. For example, give thought to `tx.origin`.",
    "id": "MWE-067"
  },
  "functiontype-var": {
    "code": "functiontype-var",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-068: Arbitrary Function Jump via Inline Assembly",
    "wiki_description": "The inline assembly can modify the logic of the `memory` function type by changing the corresponding memory, which may cause unexpected behavior.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Should not modify the function type by the inline assembly that may cause unexpected behavior.",
    "id": "MWE-068"
  },
  "bytes-variables-risk": {
    "code": "bytes-variables-risk",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-069: Risk of Variables",
    "wiki_description": "The `msg.data` apply ABI encode. So if the data is too long or short but still validated, the bytes of an ABI-encoded variable will, whether padding or truncating the low-order bytes. So that different msg.data might produce the same value assigned.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Check the input from ABI function and ensure the length of msg.data  is legitimate.",
    "id": "MWE-069"
  },
  "call-inject": {
    "code": "call-inject",
    "impact": "HIGH",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-070: Call to Arbitrary Addresses with Unchecked Calldata",
    "wiki_description": "Call to arbitrary addresses with malicious calldata may incur unexpected behavior.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Check the target address and calldata when use call",
    "id": "MWE-070"
  },
  "constant-result": {
    "code": "constant-result",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-071: Expressions with Tautology or Contradiction",
    "wiki_description": "Detects expressions that are tautologies or contradictions.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Fix the incorrect comparison by changing the value type or the comparison.",
    "id": "MWE-071"
  },
  "encode-packed": {
    "code": "encode-packed",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-072: Non-standard Encode Method `abi.encodePacked()`",
    "wiki_description": "The non-standard encode method `abi.encodePacked()` does not meet the ABI requirement. It encodes the parameters without padding for parameters less than 32 bytes and length information of dynamic arrays. As a result, we should not use it to encode parameters for any call preparation.\\nAdditionally, it may be vulnerable to increasing the possibility of hash collision.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid using the non-standard ABI encode method.",
    "id": "MWE-072"
  },
  "version-only": {
    "code": "version-only",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-073: Floating Pragma",
    "wiki_description": "An unlocked compiler version like ^0.8.0 in the contract's source code permits the user to compile it at or above a particular version, which leads to differences in the generated bytecode between compilations due to differing compiler version numbers. As a result, compiler-specific bugs may occur in the codebase that would be hard to identify throughout multiple compiler versions rather than a specific one, which can cause ambiguity. Moreover, the contracts may be at the risk of being accidentally deployed using an outdated compiler version which can introduce bugs to affect the contract system negatively.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Lock the compiler version to the lowest version possible so that the contract can be compiled and consider known bugs for the chosen compiler version.",
    "id": "MWE-073"
  },
  "incorrect-inheritance-order": {
    "code": "incorrect-inheritance-order",
    "impact": "LOW",
    "confidence": "LOW",
    "wiki": "",
    "wiki_title": "MWE-074: Incorrect Inheritance Order ",
    "wiki_description": "Solidity supports multiple inheritances, meaning that one contract can inherit several contracts. However, multiple inheritances introduce ambiguity called Diamond Problem: if two or more base contracts define the same function, which one should be called in the child contract? Solidity deals with this ambiguity using reverse C3 Linearization, which sets a priority between base contracts.\\n That way, base contracts have different priorities, so the order of inheritance matters. Neglecting inheritance order can lead to unexpected behavior.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Developers should carefully specify inheritance in the correct order when inheriting multiple contracts, especially if they have identical functions. The rule of thumb is to inherit contracts from more general to more specific.",
    "id": "MWE-074"
  },
  "hardcode-gas-amount": {
    "code": "hardcode-gas-amount",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-075: `transfer()` and `send()` with Hardcoded Gas Amount ",
    "wiki_description": "The `transfer()` and `send()` functions forward a fixed amount of 2300 gas. Historically, it has often been recommended to use these functions for value transfers to guarding against reentrancy attacks. However, the gas cost of EVM instructions may change significantly during hard forks, breaking already deployed contract systems that make fixed assumptions about gas costs. For example. EIP 1884 broke several existing smart contracts due to a cost increase in the SLOAD instruction.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid the use of `transfer()` and `send()` and do not otherwise specify a fixed amount of gas when performing calls. Use `.call.value(...)` instead. Use the checks-effects-interactions pattern or reentrancy locks to prevent reentrancy attacks.",
    "id": "MWE-075"
  },
  "uncontrolled-resource-consumption": {
    "code": "uncontrolled-resource-consumption",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-076: DoS with Block Gas Limit ",
    "wiki_description": "When smart contracts are deployed, functions inside them are called, and the execution of these actions always requires a certain amount of gas based on how much computation is needed to complete them. The Ethereum network specifies a block gas limit, and the sum of all transactions included in a block can not exceed the threshold.\\nProgramming patterns that are harmless in centralized applications can lead to Denial of Service conditions in smart contracts when the cost of executing a function exceeds the block gas limit. For example, modifying an array of unknown size that increases over time can lead to a Denial of Service condition.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Caution is advised when you expect to have large arrays that grow over time. Actions that require looping across the entire data structure should be avoided.\\n If you absolutely must loop over an array of unknown size, then you should plan for it to take multiple blocks and potentially require multiple transactions.",
    "id": "MWE-076"
  },
  "no-license": {
    "code": "no-license",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-077: Missing SPDX License Identifier ",
    "wiki_description": "The SPDX license identifier is not provided in the source contract. However, it is still good practice to include SPDX license identifiers when using solidity compiler version 0.6.8 and below, in which the license identifiers are not introduced yet.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Insert the SPDX license identifier in the first line of every contract before publishing them.",
    "id": "MWE-077"
  },
  "missing-mutability": {
    "code": "missing-mutability",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-078: Missing Mutability Specifier ",
    "wiki_description": "The mutability specifiers are missing for variables that are assigned only once, either during the contract-level declaration or the execution of the constructor. This can lead to unnecessary gas consumption when utilizing these variables.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add the mutability specifier for variables that are assigned only once. The constant keyword is recommended for the former case, and the immutable keyword is recommended for the latter case.",
    "id": "MWE-078"
  },
  "initialize-permission": {
    "code": "initialize-permission",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-079: Initializing Method without Permission Check",
    "wiki_description": "Initialize method of the protocol without permission check might be manipulated by hackers.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Initialize method should has a permission check",
    "id": "MWE-079"
  },
  "order-layout": {
    "code": "order-layout",
    "impact": "INFORMATIONAL",
    "confidence": "INFORMATIONAL",
    "wiki": "",
    "wiki_title": "MWE-080: Non-standard Order of Layout ",
    "wiki_description": "The contract has non-standard order of layout.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Inside each contract, library or interface, use the following order:\n\n1. Type declarations;\n\n2. State variables;\n\n3. Events;\n\n4. Modifiers;\n\n5. Functions.",
    "id": "MWE-080"
  },
  "using-for-any-type": {
    "code": "using-for-any-type",
    "impact": "INFORMATIONAL",
    "confidence": "INFORMATIONAL",
    "wiki": "",
    "wiki_title": "MWE-081: Using Any Type '*' ",
    "wiki_description": "Using for any type '*'.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid use '*' in 'using for' statement.",
    "id": "MWE-081"
  },
  "function-visibility": {
    "code": "function-visibility",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-082: Default Function Visibility ",
    "wiki_description": "Functions that do not have a function visibility type specified are public by default, Which can lead to a vulnerability if a developer forgets to set the visibility. A malicious user can make unauthorized or unintended state changes.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Functions can be specified as being external, public, internal or private. It is recommended to make a conscious decision on which visibility type is appropriate for a function, which can dramatically reduce the attack surface of a contract system.",
    "id": "MWE-082"
  },
  "unused-event": {
    "code": "unused-event",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-083: Unused events",
    "wiki_description": "The presence of events that are declared but never used in the codebase. They may increase computation costs and lead to unnecessary gas consumption.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove unused events or emit them in the right place to avoid negative effects and improve code readability if there is no plan for further usage.",
    "id": "MWE-083"
  },
  "variable-scope": {
    "code": "variable-scope",
    "impact": "LOW",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-084: Possible Usage of a Variable before Declaration",
    "wiki_description": "Detects the possible usage of a variable before the declaration is stepped over (either because it is later declared or declared in another scope).",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Move all variable declarations before any variable usage, and ensure that reaching a variable declaration does not depend on some conditional if used unconditionally.",
    "id": "MWE-084"
  },
  "naming-convention": {
    "code": "naming-convention",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-085: Inappropriate Solidity Naming Conventions ",
    "wiki_description": "Solidity defines a [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions) that should be followed.\n\n#### Rule exceptions\n\n- Allow constant variable name/symbol/decimals to be lowercase (`ERC20`).\n\n- Allow `_` at the beginning of the `mixed_case` match for private variables and unused parameters.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Follow the Solidity [naming convention](https://solidity.readthedocs.io/en/v0.4.25/style-guide.html#naming-conventions).",
    "id": "MWE-085"
  },
  "dead-function": {
    "code": "dead-function",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-086: Unused Internal Functions ",
    "wiki_description": "Presence of internal functions that are defined but never used in the contract. Such functions may introduce unnecessary gas consumption and make the code's review more difficult.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove unused functions to save gas and improve code readability.",
    "id": "MWE-086"
  },
  "uninitialized-local": {
    "code": "uninitialized-local",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-087: Uninitialized Local Variables ",
    "wiki_description": "A local variable is either never initialized or is initialized only under certain conditions, while the variable will be used regardless of its initialization. As a result, the default zero value is used, which is not desired.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Initialize the local variable to a reasonable value. Explicitly setting it to zero if it is meant to be initialized to zero.",
    "id": "MWE-087"
  },
  "unused-return": {
    "code": "unused-return",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-088: Unused Return Value ",
    "wiki_description": "Either the return value of an external call is not stored in a local or state variable, or the return value is declared but never used in the function body.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Ensure the return value of external function calls is used. Remove or comment out the unused return function parameters.",
    "id": "MWE-088"
  },
  "assembly-usage": {
    "code": "assembly-usage",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-089: Error-prone Assembly Usage ",
    "wiki_description": "The use of assembly is error-prone and should be avoided.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "We advise against using EVM assembly, as it is error-prone.",
    "id": "MWE-089"
  },
  "public-mint-burn": {
    "code": "public-mint-burn",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-90: Usage of public mint or burn",
    "wiki_description": "Public mint or burn method are dangerous for token, anyone can manipulate token balance which may lead to negative effects.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Add permission check for mint() or burn() methods.",
    "id": "MWE-90"
  },
  "two-step-change-key-address": {
    "code": "two-step-change-key-address",
    "impact": "HIGH",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-091: Unsafe Key Address Change",
    "wiki_description": "Key address change should be updated in two steps.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid directly assignment for key address.",
    "id": "MWE-091"
  },
  "arbitrary-send-erc20-no-permit": {
    "code": "arbitrary-send-erc20-no-permit",
    "impact": "CRITICAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-092: Arbitrary `from` in transferFrom() without msg.sender Check ",
    "wiki_description": "Detect when `msg.sender` is not used as `from` in `transferFrom` and does not have a modifier that has `msg.sender` check.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use `msg.sender` as `from` in `transferFrom`, or add a modifier with `msg.sender` check.",
    "id": "MWE-092"
  },
  "function-init-state": {
    "code": "function-init-state",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-093: Dangerour Immediate Initialization of State Variables ",
    "wiki_description": "Detects the immediate initialization of state variables through function calls that are not pure/constant or use non-constant state variables.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Remove any initialization of state variables via non-constant state variables or function calls. If variables must be set upon contract deployment, locate initialization in the constructor instead.",
    "id": "MWE-093"
  },
  "incorrect-equality": {
    "code": "incorrect-equality",
    "impact": "INFORMATIONAL",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-094: Dangerous Strict Equality without `msg.sender` Check in modifier ",
    "wiki_description": "Use of strict equalities that an attacker can easily manipulate.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Don't use strict equality to determine if an account has enough Ether or tokens. Or must have a modifier to access control.",
    "id": "MWE-094"
  },
  "integer-overflow": {
    "code": "integer-overflow",
    "impact": "MEDIUM",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-095: Integer Overflow",
    "wiki_description": "Overflow is a situation when an unsigned integer reaches its byte size. Then the next element added will return the first variable element. On the contrary, underflow means the preview element will return the last variable element. In Solidity 0.8, the compiler will automatically check for overflow and underflow.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Use solc version above 0.8, or use OpenZeppelin\u2019s SafeMath.sol implementation.",
    "id": "MWE-095"
  },
  "unnecessary-reentrancy-lock": {
    "code": "unnecessary-reentrancy-lock",
    "impact": "OPTIMIZATION",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-096: Unnecessary Reentrancy Lock ",
    "wiki_description": "If there has no call in the function, the reentrancy lock is unnecessary and can be replaced by the `require` logic.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Replace with require logic.",
    "id": "MWE-096"
  },
  "send-in-contract": {
    "code": "send-in-contract",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-097: Unsafe send() in the require() Condition",
    "wiki_description": "if there is send in require logic, the logic may revert from recipient by return false, cause dos attack.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "use transfer logic instead of send.",
    "id": "MWE-097"
  },
  "force-send-ether-cause-revert": {
    "code": "force-send-ether-cause-revert",
    "impact": "HIGH",
    "confidence": "HIGH",
    "wiki": "",
    "wiki_title": "MWE-098: Foce Sending Ether with this.balance check in require() or assert() ",
    "wiki_description": "if there is force send ether in function(use `selfdestruct`) and also have require or assert check with `this.balance`, the attacker may use force send ether to mislead ether balance of contract, let the contract will always failed in force send ether",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "use transfer logic instead of send.",
    "id": "MWE-098"
  },
  "price-manipulation-high": {
    "code": "price-manipulation-high",
    "impact": "CRITICAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-099: Possibility of Price manipulation with Pool Reserves",
    "wiki_description": "Please check all child function call based on this expression or expression itself, the potential price manipulation risk may in it. for example, in some functions, certain variables used in `transfer` or `mint` or `return` procedures depend on another dangerous variable that derives its data from `balanceof`, `getReserve`, `totalSupply()` or `address(someAddress).balance` and is vulnerable to manipulation by flash loan.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "It is recommended to use the chainlink oracle to obtain data, or to avoid relying on easily manipulated variables, or to use the TWAP mechanism.",
    "id": "MWE-099",
    "custom_description":true
  },
  "price-manipulation-medium": {
    "code": "price-manipulation-medium",
    "impact": "MEDIUM",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-100: Possibility of Price manipulation with Balances",
    "wiki_description": "Please check all child function call based on this expression or expression itself, the potential price manipulation risk may in it. for example, in some functions, certain variables used in `transfer` or `mint` or `return` procedures depend on another dangerous variable that derives its data from `balanceof`, `getReserve`, `totalSupply()` or `address(someAddress).balance` and is vulnerable to manipulation by flash loan.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "It is recommended to use the chainlink oracle to obtain data, or to avoid relying on easily manipulated variables, or to use the TWAP mechanism.",
    "id": "MWE-100",
    "custom_description":true
  },
  "defi-action-nested": {
    "code": "defi-action-nested",
    "impact": "HIGH",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-101: Arbitrage Risk in Nested DeFi Actions ",
    "wiki_description": "Potential nested defi action in another defi action, which has a risk of indirectly generating arbitrage space",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "Avoid unexpected swap or other defi action in another defi action",
    "id": "MWE-101"
  },
  "centralized-risk-medium":{
    "code":"centralized-risk-medium",
    "impact":"MEDIUM",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-102: Centralized Risk With Coin Transfer",
    "wiki_description":"The contract has a centralized risk, which means that the contract is controlled by a single address. If the address is compromised, the contract will be compromised.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Avoid using centralized risk contracts.",
    "id":"MWE-102"
  },
  "modifier-unsafe":{
    "code":"modifier-unsafe",
    "impact":"HIGH",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-103: Unsafe Modifier",
    "wiki_description":"Modifiers are used to modify the behavior of functions in smart contracts, and they can be used to add additional security checks or restrictions on function calls. However, if a modifier is not properly implemented or secured, it can be bypassed by an attacker, allowing them to exploit the contract and potentially steal funds.\n The vulnerability arises when a modifier is not properly designed or implemented, allowing an attacker to bypass it and execute a function without the intended security checks. This can happen due to various reasons such as incorrect implementation of the modifier code, insufficient testing of the modifier functionality, or lack of understanding of how modifiers work.\n Attackers can exploit this vulnerability by finding a way to bypass the modifier and execute a function that should have been restricted. This can lead to various types of attacks such as re-entrancy attacks, where an attacker repeatedly calls a vulnerable contract function before the previous call has completed, allowing them to drain funds from the contract.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Consideration should be given to establish robust access control policies for contract functions, and regular security checks should be conducted using tools like SoMo to ensure the secure execution of the contracts.",
    "id":"MWE-103"
  },
  "centralized-risk-low":{
    "code":"centralized-risk-low",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-104: Centralized Risk With Transfer Related Variable Setting", 
    "wiki_description":"The contract has a centralized risk, which means that the contract is controlled by a single address. If the address is compromised, the contract will be compromised.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Avoid using centralized risk contracts.",
    "id":"MWE-104"
  },
  "missing-zero-check":{
    "code":"missing-zero-check",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-105: Missing Zero Address Check", 
    "wiki_description":"This Function is lack of zero address check in important operation, which may cause some unexpected result.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Add check of zero address in important operation.",
    "id":"MWE-105"
  },
  "transfer-in-loop":{
    "code":"transfer-in-loop",
    "impact":"MEDIUM",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-106: Transfer in Loop", 
    "wiki_description":"The use of the transfer function in Ethereum smart contracts can potentially lead to a DOS (Denial-of-Service) attack, as it automatically reverts the entire transaction if there isn't enough gas for the called contract, possibly locking funds.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"To avoid DOS attacks, use the send or call.value functions instead of transfer, as they allow for better error handling by not reverting the entire transaction when the called contract fails due to insufficient gas.",
    "id":"MWE-106"
  },
  "centralized-risk-informational":{
    "code":"centralized-risk-informational",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-107: Centralized Risk With Key Variable Setting", 
    "wiki_description":"The contract has a centralized risk, which means that the contract is controlled by a single address. If the address is compromised, the contract will be compromised.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Avoid using centralized risk contracts.",
    "id":"MWE-107"
  },
  "centralized-risk-other":{
    "code":"centralized-risk-other",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-108: Centralized Risk With Other Variable Read", 
    "wiki_description":"The contract has a centralized risk, which means that the contract is controlled by a single address. If the address is compromised, the contract will be compromised.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Avoid using centralized risk contracts.",
    "id":"MWE-108"
  },
  "tx-gas-price-warning":{
    "code":"tx-gas-price-warning",
    "impact":"MEDIUM",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-109: TX Gasprice Warning ", 
    "wiki_description":"Tx.gasprice variable must be used carefully.",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Make sure that tx.gasprice varible which is set by users does not exploit the contract logic。",
    "id":"MWE-109"
  },
  "pess-event-setter":{
    "code":"pess-event-setter",
    "impact":"INFORMATIONAL"                                                                                                                                                                                                                   ,
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-110: Missing Event Setter ", 
    "wiki_description":"Setter-functions must emit events",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Emit events in setter functions",
    "id":"MWE-110"
  },
  "pess-strange-setter":{
    "code":"pess-strange-setter",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-111: Strange Setter ", 
    "wiki_description":"Setter must write to storage variables",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Make sure that your setter actually sets something",
    "id":"MWE-111"
  },
  "pess-only-eoa-check":{
    "code":"pess-only-eoa-check",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-112: Falsy Only EOA Modifier ", 
    "wiki_description":"Logic msg.sender == tx.origin must be removed",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Do not rely on logic msg.sender == tx.origin when protecting contract logic",
    "id":"MWE-112"
  },
  "for-continue-increment":{
    "code":"for-continue-increment",
    "impact":"MEDIUM",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-113: For continue increment ", 
    "wiki_description":"A continue statement before an unchecked index increment can turn into an infinite loop",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Increment the loop index before the continue statement",
    "id":"MWE-113"
  },
  "logic-error":{
    "code":"logic-error",
    "impact":"MEDIUM",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-114: Logic Error", 
    "wiki_description":"A continue statement before an unchecked index increment can turn into an infinite loop",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Please Follow the recommendation in the description.",
    "id":"MWE-114",
    "custom_description":true
  },
  "unnecessary-reentrancy-guard":{
    "code":"unnecessary-reentrancy-guard",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-115: Unnecessary Reentrancy Guard", 
    "wiki_description":"Detect the contract which has unnecessary reentrancy guard",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Remove the reentrancy guard",
    "id":"MWE-115"
  },
  "void-function":{
    "code":"void-function",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-116: Void Function", 
    "wiki_description":"Detect the contract which has void function",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Implement the function",
    "id":"MWE-116"
  },
  "unnecessary-public-function-modifier":{
    "code":"unnecessary-public-function-modifier",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-117: Unnecessary Public Function Modifier", 
    "wiki_description":"Detect the public function which can be replaced with external",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Replace public with external",
    "id":"MWE-117"
  },
  "state-variable-not-initialized":{
    "code":"state-variable-not-initialized",
    "impact":"LOW",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-118: State variable not Initialized or Written", 
    "wiki_description":"A state variable not initialized and not written in contract but be used in contract",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Initialize the state variable",
    "id":"MWE-118"
  },
  "centralized-init-supply":{
    "code":"centralized-init-supply",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-119: Centralized Risk with Token Supply", 
    "wiki_description":"centrlized risk with supply totalsupply token in constructor during initial the contract",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Avoid using centralized risk logic.",
    "id":"MWE-119"
  },
  "too-many-digits":{
    "code":"too-many-digits",
    "impact":"INFORMATIONAL",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-120: Too many digits in the number", 
    "wiki_description":"Too many digits in the number",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"using ** or ^ instead of too many digits.",
    "id":"MWE-120"
  },
  "k-value-error":{
    "code":"k-value-error",
    "impact":"HIGH",
    "confidence":"HIGH",
    "wiki":"",
    "wiki_title":"MWE-121: K Value Calculation Error In Uniswap-like Contract", 
    "wiki_description":"K Value Calculation Error In Uniswap-like Contract, When calculating the K value, it is important to ensure that the order of magnitude on both sides is the same",
    "wiki_exploit_scenario":"",
    "wiki_recommendation":"Set both magnitudes to be the same magnitude.",
    "id":"MWE-121"
  },
  "price-manipulation-low": {
    "code": "price-manipulation-low",
    "impact": "LOW",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-0122: Possibility of Price manipulation with Pool Reserves",
    "wiki_description": "Please check all child function call based on this expression or expression itself, the potential price manipulation risk may in it. for example, in some functions, certain variables used in `transfer` or `mint` or `return` procedures depend on another dangerous variable that derives its data from `balanceof`, `getReserve`, `totalSupply()` or `address(someAddress).balance` and is vulnerable to manipulation by flash loan.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "It is recommended to use the chainlink oracle to obtain data, or to avoid relying on easily manipulated variables, or to use the TWAP mechanism.",
    "id": "MWE-122",
    "custom_description":true
  },
  "price-manipulation-info": {
    "code": "price-manipulation-info",
    "impact": "INFORMATIONAL",
    "confidence": "MEDIUM",
    "wiki": "",
    "wiki_title": "MWE-0123: Possibility of Price manipulation with Balances",
    "wiki_description": "Please check all child function call based on this expression or expression itself, the potential price manipulation risk may in it. for example, in some functions, certain variables used in `transfer` or `mint` or `return` procedures depend on another dangerous variable that derives its data from `balanceof`, `getReserve`, `totalSupply()` or `address(someAddress).balance` and is vulnerable to manipulation by flash loan.",
    "wiki_exploit_scenario": "",
    "wiki_recommendation": "It is recommended to use the chainlink oracle to obtain data, or to avoid relying on easily manipulated variables, or to use the TWAP mechanism.",
    "id": "MWE-123",
    "custom_description":true
  }


}